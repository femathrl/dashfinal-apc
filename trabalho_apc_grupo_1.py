# -*- coding: utf-8 -*-
"""Trabalho APC - Grupo 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gH1E-Dh-9c7BOujxSqxGzRpzq9i_VjWo

# Grupo 1 -  Análises sobre barris de petróleo não refinado
**Membros:**
- Luciano Medeiros Bogéa Viana (222015168)
- Gustavo Santos Freitas (222015130)
- Pedro Ramos Sousa Reis (222031680)
- Gustavo Henrique Evangelista Santos Silva (222027463)
- Felipe Matheus Ribeiro Lopes (221031274)
- Felipe Ribeiro de Oliveira França (222014993)
- João Victor Tavares de Souza (222015140)
- Eduarda de Aro Passari (222031143)
- Karla de Sousa Rodrigues (222031448)
- Lucca Medeiros Silva (222031528)

## Introdução
Neste trabalho serão apresentadas cinco análises utilizando dados referentes ao fluxo (monetário e volumétrico/quantitativo) de barris de petróleo não refinado ao redor do mundo, tendo como base dados disponibilizados pelo Yahoo Finanças, durante o período de 01/07/2002 até 01/07/2022.

As análises apresentadas neste trabalho serão enumeradas de 1 a 5, considerando que cada uma delas possui sua respectiva descrição, que contém uma explicação do código e dos valores resultantes mostrados no gráfico.

## Base de dados utilizada

|Nome|Descrição|Colunas|Linhas|
|:---|:---|--:|--:|
|[Crude Oil price data](https://www.kaggle.com/datasets/ramsesloaces/crude-oil-stock-data)|Base de dados original (link do Kaggle).|7|5030|
|[Dados não tratados](https://raw.githubusercontent.com/StuFordy/APC/main/CrudeOil.csv)|Mesma base com dados do Kaggle, porém não tratados, utilizada para importação no código (link do GitHub).|7|5030|

## Preparação do ambiente de programação
- Para a execução das análises é necessário importar as bibliotecas que serão utilizadas ao longo de todos os códigos. `REFERÊNCIA 1`

- Ademais, é preciso ler a base de dados utilizando os dados não tratados que foram acessados por meio do link do GitHub mencionado anteriormente. `REFERÊNCIA 2`

- Nesta parte, estão as listas utilizadas ao longo dos códigos de todas as análises. Para isso utilizou-se o "tolist()" para transformar uma determinada coluna do dataframe em uma lista com os dados dessa coluna.  `REFERÊNCIA 3`
"""

#REFERÊNCIA 1
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

#REFERÊNCIA 2
Dataframeutilizado = pd.read_csv('https://raw.githubusercontent.com/StuFordy/APC/main/CrudeOil.csv')

#REFERÊNCIA 3
ListaDataframeutilizado = Dataframeutilizado.values.tolist()
ListaDeDatas = Dataframeutilizado['Date'].tolist()
ListaDeOpens = Dataframeutilizado['Open'].tolist()
ListaDeCloses = Dataframeutilizado['Close*'].tolist()
ListaDeVolumes = Dataframeutilizado['Volume'].tolist()
ListaDeHighs = Dataframeutilizado['High'].tolist()
ListaDeLows = Dataframeutilizado['Low'].tolist()

"""##Análise 1 - Média de volume por ano
`Descrição da análise:` Com essa análise poderemos quantificar, para um ano, o quanto de volume foi movimentado (tirando a média considerando os valores diários).

- Antes de trabalhar com os dados do "Dataframeutilizado", precisamos tratar eles uma vez que esses dados vem com vírgulas, e o Python não consegue identificar isso como um número inteiro. Por isso, definimos uma função "substituicao" que retira todas as vírgulas dos dados utilizados. `REFERÊNCIA 1`
- Esta função map aplica a função "substituicao" em todos os elementos da lista "ListaDeVolumes", que são todos os valores de volume. Ou seja, retira todas as vírgulas. `REFERÊNCIA 2`
- Por fim, utilizamos a função "eval" para transformar todos os dados da lista "LVSemVirgula" de string para número. `REFERÊNCIA 3`
"""

#REFERÊNCIA 1
def substituicao(x):
  return x.replace(',', '')

#REFERÊNCIA 2  345,675 = 345675
LVSemVirgula = map(substituicao, ListaDeVolumes)

#REFERÊNCIA 3
LVConvertida = [eval(z) for z in LVSemVirgula]

"""- Precisamos definir uma função que chamamos de "volume" que recebe o parâmetro "ano". Essa é a função que vai calcular o volume médio em barris de petróleo, negociados em um ano específico. `REFERÊNCIA 4`
- Criamos, então, duas listas vazias que serão preenchidas por um loop. A lista "lista_vol" vai guardar todos os valores da "LVConvertida" que corresponderem ao ano recebido pela função, e a lista "indices" vai servir para armazenar os dados de acordo com o que passar pelo filtro, mostrado posteriormente. `REFERÊNCIA 5`
- É preciso transformar o número "ano" recebido pela função em uma string, pois, somente assim o filtro mencionado vai funcionar. `REFERÊNCIA 6`
- Esse é o filtro que vai identificar o ano recebido dentro da "ListaDeDatas" do "Dataframeutilizado", e colocar os respectivos valores do contador que correspondem às informações, dentro da lista "indices". Ou seja, vai armazenar o volume de todos os dias do ano escolhido, dentro da lista "lista_vol", e associar esses dados a um valor da lista índice. `REFERÊNCIA 7`
- Agora, é preciso calcular a média dos volumes de petróleo. Isso é feito somando todos os valores da lista "lista_vol" e dividindo pelo length dessa mesma lista. `REFERÊNCIA 8`
"""

#REFERÊNCIA 4
def volume(ano):
  #REFERÊNCIA 5
  lista_vol = []
  indices = []
  contador = 0
  #REFERÊNCIA 6
  ano = str(ano)
  #REFERÊNCIA 7
  for x in ListaDeDatas:
    if ano in x:
      indices.append(contador)
    contador += 1

  contador = 0 
  while contador < len(Dataframeutilizado):
    if contador in indices:
      lista_vol.append(int(LVConvertida[contador]))

    contador += 1
  #REFERÊNCIA 8
  media = sum(lista_vol)/len(lista_vol)
  return media

"""- Criou-se duas listas, as quais comporão os eixos do gráfico. Estas listas guardarão os valores das médias de volumes anuais e os anos analisados. `REFERÊNCIA 9`
- O "while" vai aplicar a função "volume" em todos os anos analisados. `REFERÊNCIA 10`
"""

#REFERÊNCIA 9
lista_media_anual_vol = []
anos = []
contador_anos = 2002
#REFERÊNCIA 10
while contador_anos < 2023:
  lista_media_anual_vol.append(volume(contador_anos))
  anos.append(contador_anos)
  contador_anos += 1

def quant_mes_volume(ano, mes):
  lista_volumes = []
  indices = []
  contador = 0
  ano = str(ano)
  mes = str(mes)
  for x in ListaDeDatas:
    if ano in x and mes in x:
      indices.append(contador)
    contador += 1
  contador = 0
  while contador < len(Dataframeutilizado):
    if contador in indices:
      lista_volumes.append(LVConvertida[contador])
    contador += 1
  lista_volumes  

  #print(lista_volumes)
  #print(len(lista_volumes))

  return lista_volumes

grafic_vol = px.data.gapminder()
px.bar(grafic_vol, x=anos, y=lista_media_anual_vol, title="MEDIA ANUAL DE VOLUME", labels={"y": "VOLUME", "x": "ANO"})

"""## Análise 2 - Preço médio do barril de petróleo por ano
`Descrição da análise:` Com essa análise poderemos quantificar, para um ano, a média do preço do barril de petróleo (levando em consideração os preços de abertura e fechamento da bolsa).
- Precisamos definir uma função que chamamos de "precos" que recebe o parâmetro "ano". Essa é a função que vai calcular o preço médio do barril de petróleo de um ano específico. `REFERÊNCIA 1`
- Criamos, então, duas listas vazias que serão preenchidas por um loop. A lista "lista_open_close" vai guardar todos os valores da "ListaDeOpens" e "ListaDeCloses" dos barris de petróleo, e a lista "indices" vai servir para armazenar os dados de acordo com o que passar pelo filtro, mostrado posteriormente. `REFERÊNCIA 2`
- É preciso transformar o número "ano" recebido pela função em uma string, pois, somente assim o filtro mencionado vai funcionar. `REFERÊNCIA 3`
- Esse é o filtro que vai identificar o ano recebido dentro da "ListaDeDatas" do "Dataframeutilizado", e colocar os respectivos valores do contador que correspondem às informações, dentro da lista "indices". Ou seja, vai armazenar o preço de abertura e fechamento de todos os dias do ano escolhido, dentro da lista "lista_open_close", e associar esses preços a um valor da lista índice. `REFERÊNCIA 4`
- Agora, é preciso calcular a média dos preços de barris de petróleo. Isso é feito somando todos os valores da lista "lista_open_close" e dividindo pelo length dessa mesma lista. `REFERÊNCIA 5`
"""

def medialista(x):
  if len(x) == 0:
    return 0
  else:
    media = sum(x)/len(x)
    return media

#REFERÊNCIA 1
def precos(ano,mes):
  #REFERÊNCIA 2
  lista_open_close = []
  indices = []
  contador = 0
  #REFERÊNCIA 3
  ano = str(ano)
  #REFERÊNCIA 4
  mes = str(mes)
  for x in ListaDeDatas:
    if ano in x and mes in x:
      indices.append(contador)
    contador += 1
  contador = 0
  while contador < len(Dataframeutilizado):
    if contador in indices:
      lista_open_close.append(ListaDeOpens[contador])
      lista_open_close.append(ListaDeCloses[contador])
    contador += 1    
  #REFERÊNCIA 5                                                                                                                                                                                                                                                                                      
  media = medialista(lista_open_close)
  media = float(media)
  return media

"""- Criou-se duas listas, as quais comporão os eixos do gráfico. Estas listas guardarão os valores das médias de preços anuais de barris de petróleo e os anos analisados. Vale ressaltar que o usuário pode definir o intervalo mostrado, pois, os anos são dados através de inputs. `REFERÊNCIA 6`
- O "while" vai aplicar a função precos em todos os anos definidos anteriormente pelo usuário. `REFERÊNCIA 7`
"""

2#REFERÊNCIA 6
lista_media_anual = []
meses = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
meses1 = []
print("Ano de início da análise: ")
contador_anos = int(input())
print("Ano final da análise: ")
ano_final = int(input())
#REFERÊNCIA 7
while contador_anos <= ano_final:
  for i in range(0,12):
    lista_media_anual.append(precos(contador_anos,meses[i]))
    meses1.append(f'{contador_anos} {meses[i]}')
  contador_anos += 1

px.line(Dataframeutilizado, x=meses1, y= lista_media_anual, title="PREÇO MÉDIO DO BARRIL DE PETRÓLEO POR ANO", labels={"y": "PREÇO MÉDIO", "x": "ANO"})

"""## Análise 3 - Capital movimentado
`Descrição da análise:` Com essa análise poderemos quantificar o quanto de capital, ou seja, de dinheiro, foi movimentado na bolsa considerando 3 situações: o preço em alta, na média e em baixa. Por isso, existem 3 gráficos nesta análise.
- Precisamos utilizar uma função (nomeada "operacao") para listar volume anual e variação dos preços por ano (High e Low). `REFERÊNCIA 1`
- Esses valores são agrupos em listas separadas para efetuarmos os cálculos utilizando operações com listas. `REFERÊNCIA 2`
- Para realizar o agrupamento anterior, utilizamos loops "for" e "while" a fim de aplicar a função "operacao" nos elementos das listas para cada ano que ela recebe. `REFERÊNCIA 3`
- A partir desses agrupamentos, para encontrar a média respectiva de cada item analisado, somamos os valores dos argumentos das listas (sum) e dividimos pelo tamanho da mesma lista (length). Para no final a função "operacao" retornar cada valor tratado. `REFERÊNCIA 4`
"""

#REFERÊNCIA 1
def operacao(ano):
  #REFERÊNCIA 2
  ListaVolumeAno = []
  ListaHighAno = []
  ListaLowAno = []
  indices = []
  contador = 0
  ano = str(ano)
  #REFERÊNCIA 3
  for x in ListaDeDatas:
    if ano in x:
      indices.append(contador)
    contador += 1
  contador = 0
  while contador < len(Dataframeutilizado):
    if contador in indices:
      ListaVolumeAno.append(LVConvertida[contador])
      ListaHighAno.append(ListaDeHighs[contador])
      ListaLowAno.append(ListaDeLows[contador]) 
    contador += 1
  #REFERÊNCIA 4
  MediaValoresVolume = sum(ListaVolumeAno)/len(ListaVolumeAno)   
  MediaValoresLow = sum(ListaLowAno)/len(ListaLowAno)
  MediaValoresMid = (sum(ListaHighAno)+sum(ListaLowAno))/(len(ListaHighAno)+len(ListaLowAno))
  MediaValoresHigh = sum(ListaHighAno)/len(ListaHighAno) 

  CapitalMovimentadoLow = MediaValoresVolume*MediaValoresLow
  CapitalMovimentadoMid = MediaValoresVolume*MediaValoresMid
  CapitalMovimentadoHigh = MediaValoresVolume*MediaValoresHigh

  return CapitalMovimentadoLow,CapitalMovimentadoMid,CapitalMovimentadoHigh,MediaValoresVolume

"""- Para a construção do gráfico, aplicamos loops nos dados desejados (Capitais Movimentados - Low x Volume, Mid x Volume e High x Volume) em ordem de obter as médias de cada ano. `REFERÊNCIA 5` """

#REFERÊNCIA 5
MediasAnuais = []
Anos = []
ContadorAnos = 2002
while ContadorAnos < 2023:
  MediasAnuais.append(operacao(ContadorAnos))
  Anos.append(ContadorAnos)
  ContadorAnos += 1

ContadorAnos = 2002
ListaCapitalMovimentadoLow = []
while ContadorAnos < 2023:
  for i in range(21):
    ListaCapitalMovimentadoLow.append(MediasAnuais[i][0])
    ContadorAnos += 1

ContadorAnos = 2002
ListaCapitalMovimentadoMid = []
while ContadorAnos < 2023:
  for i in range(21):
    ListaCapitalMovimentadoMid.append(MediasAnuais[i][1])
    ContadorAnos += 1

ContadorAnos = 2002
ListaCapitalMovimentadoHigh = []
while ContadorAnos < 2023:
  for i in range(21):
    ListaCapitalMovimentadoHigh.append(MediasAnuais[i][2])
    ContadorAnos += 1

"""- Com isso, fizemos um gráfico analisando a variação do capital movimentado em três instâncias: Low, Mid e High; para uma possível análise financeira do capital investido. `REFERÊNCIA 6`"""

#REFERÊNCIA 6
GraficoCapitalMovimentado = go.Figure(
    layout=go.Layout(
        title=go.layout.Title(text="CAPITAL MOVIMENTADO - CURVAS COM PREÇOS EM ALTA, MÉDIA E BAIXA"),
        yaxis_title="CAPITAL MOVIMENTADO",
        xaxis_title="ANO"))

GraficoCapitalMovimentado.add_trace(
    go.Scatter(x=Anos,
               y=ListaCapitalMovimentadoHigh,
               name="EM ALTA",
               line=dict(color="#09d616")))
GraficoCapitalMovimentado.add_trace(
    go.Scatter(x=Anos,
               y=ListaCapitalMovimentadoMid,
               name="MÉDIO",
               line=dict(color="#ffe320")))
GraficoCapitalMovimentado.add_trace(
    go.Scatter(x=Anos,
               y=ListaCapitalMovimentadoLow,
               name="EM BAIXA",
               line=dict(color="#e70606")))

"""## Análise 4 - Variação de preços considerando a abertura e o fechamento da bolsa
`Descrição da análise:` Com essa análise poderemos quantificar a tendência de alta/baixa dos preços dos barris de petróleo em cada mês, utilizando dados dos 21 anos do dataframe.
- Definição dos meses - Foi definido os meses em uma lista para serem informados através do parâmetro na função "calcularVariacao", para dessa forma, os meses informados serão pesquisados em um looping nas próximas linhas de código. `REFERÊNCIA 1`
- Variação - Essa variável foi explicítada no código para definir uma lista que será responsável por informar todas as variações de determinado mês. Essa variável será definida também na função "calcularVariacao". `REFERÊNCIA 2`
- Filtrar todos os dias de determinado mês - A responsabilidade dessa função é ser informada através de seus parâmetros o dataframe, e o determinado mês que será filtrado; a varíavel pdfmes é uma variável local da função que será responsável por armazenar todos os dias com o mês que foi filtrado. Na linha pdf.iterrows retorna o índice da linha e os dados completos da linha como uma Series. Portanto, poderíamos utilizar para iterar sobre as linhas em Pandas DataFrame. Na linha do if, é verificado se o mês informado no parâmetro apresenta no campo do "Date" no DataFrame, se caso for positivo, ele irá adicionar as informações "Date","Open", "Close" na variável pdfmes. Por fim, será retornado a variável pdfmes da função filtroMeses. `REFERÊNCIA 3`
- Calcular a Diferença entre Abertura e Fechamento da Bolsa - Nessa função será recebido o return do filtroMeses, que no caso, será o resultado do pdfmes. Será definido uma variável result com o valor 0, essa variável será responsável por ser o resultado do valor da variância de "Open" e "Close" dos dias de determinado mês que foi informado no parâmetro anteriormente. Após isso, será chamado um FOR para realizar o cálculo de cada dia, sendo adicionado na variável "result" em seguida. Quando for finalizado o FOR, será adicionado o result de determinado mês na lista variacao. `REFERÊNCIA 4`
- Calcular a Variação de cada mês - Esse FOR criado é para realizar a pesquisa para todos os meses da variável meses. `REFERÊNCIA 5`
"""

#REFERÊNCIA 1
meses = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
mesesTraduzidos = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]

#REFERÊNCIA 2
variacao = []

#REFERÊNCIA 3
def filtroMeses(pdf, pmes):
  pdfmes = []
  for x in pdf:
    if x[0][:3] == pmes:
      pdfmes.append([x[0], x[1], x[4]])
  return(pdfmes)

#REFERÊNCIA 4
def calcularVariacao(days):
    result = 0
    for i in days:
        result += i[2]-i[1]
    variacao.append(result)

#REFERÊNCIA 5
for x in range(0, 12):
    calcularVariacao(filtroMeses(ListaDataframeutilizado, meses[x]))

"""- Apresentar o Gráfico - O gráfico é apresentado com o X representando os meses de todos os anos que foram realizado as variações, e o Y está todas as variações de seus respectivos meses que foram calculados. `REFERÊNCIA 7`"""

#REFERÊNCIA 6
px.bar(Dataframeutilizado, x=mesesTraduzidos, y= variacao, title="VARIAÇÃO DE PREÇOS CONSIDERANDO A ABERTURA E O FECHAMENTO DA BOLSA", labels={"y": "VARIAÇÃO", "x": "ANO"})

"""## Análise 5 - Capital movimentado com base no preço de fechamento da bolsa
`Descrição da análise:` Com essa análise poderemos quantificar, para cada mês, o quanto de capital foi movimentado (considerando os valores de abertura e fechamento da bolsa).
- Criou-se uma função que conseguisse escolher o mês e o ano específico para podermos colocar no gráfico depois. `REFERÊNCIA 1`
- Aqui foram criadas duas listas que serão usadas posteriormente, assim como um contador para marcas os itens na "ListaDeDatas". `REFERÊNCIA 2`
- Depois, definiu-se duas variáveis (ano e mes) e transformamos elas em strings para podermos comparar elas com os itens da "ListaDeDatas". `REFERÊNCIA 3`
- Esse "for" vai passar por toda a ListaDeDatas e vai verificar cada item que tiver o mês e o ano específico. Se tiver, ele vai adicionar esse item na lista "indices" e vai adicionar 1 ao contador. `REFERÊNCIA 4`
- Esse "while" vai verificar se o numero do contador está na lista "indices" e, caso sim, ele vai adicionar à "lista_closes" esse mesmo número da "ListaDeCloses" e vai somar um ao contador. `REFERÊNCIA 5`
- Esta função faz a mesma coisa que a função anterior, mas utilizando a "LVConvertida" ao invés da "ListaDeCloses". `REFERÊNCIA 6`
"""

#REFERÊNCIA 1
def precos_mes_fechamento(ano, mes):
  #REFERÊNCIA 2 
  lista_closes = []
  indices = []
  contador = 0
  #REFERÊNCIA 3 
  ano = str(ano)
  mes = str(mes)
  #REFERÊNCIA 4 
  for x in ListaDeDatas:
    if ano in x and mes in x:
      indices.append(contador)
    contador += 1
  contador = 0
  #REFERÊNCIA 5 
  while contador < len(Dataframeutilizado):
    if contador in indices:
      lista_closes.append(ListaDeCloses[contador])
    contador += 1
  lista_closes 

  #print(lista_closes)
  #print(len(lista_closes))  

  return lista_closes                                                                                                                                                                                                                                                                                       
#REFERÊNCIA 6 
def quant_mes_volume(ano, mes):
  lista_volumes = []
  indices = []
  contador = 0
  ano = str(ano)
  mes = str(mes)
  for x in ListaDeDatas:
    if ano in x and mes in x:
      indices.append(contador)
    contador += 1
  contador = 0
  while contador < len(Dataframeutilizado):
    if contador in indices:
      lista_volumes.append(LVConvertida[contador])
    contador += 1
  lista_volumes  

  #print(lista_volumes)
  #print(len(lista_volumes))

  return lista_volumes

#precos_mes_fechamento(2022, 'Jan')
#quant_mes_volume(2022, 'Jan')

"""- Criamos uma função que que seria capaz de calcular a média de duas listas distintas em apenas uma, onde os argumentos são duas listas 1D. `REFERENCIA 7`
- Definimos duas listas vazia para armazenar duas listas simples, sendo essas variações dos argumentos. `REFERENCIA 8`
- Precisa-se verificar se as listas de argumento não possuem valor (0) pois ocorre o erro de divisão por 0. `REFERENCIA 9`
- O "for" verifica o tamanho das 2 listas, lista "y" e lista "x", e adiciona as 2 listas em uma lista = "i" no modelo (y1,x1,y2,x2,yn,xn). `REFERENCIA 10`
- Precisamos de um for que multiplica os itens ímpares, todos da lista "y", com os pares, todos da lista "x" adicionando o resultado a lista = "o". `REFERENCIA 11`
- Para calcular a média usamos a função "sum", que soma toda a lista, e ‘len’ que é quantos itens que tem na lista. `REFERENCIA 12`
"""

#REFERÊNCIA 7
def medialistas(x, y):
  #REFERÊNCIA 8 
  i = []
  o = []

  #REFERÊNCIA 9 
  if len(y) == 0:
    return 0
  else:
    #REFERÊNCIA 10
    for n in range(len(y)):
      i.append(y[n])
      i.append(x[n])

    #REFERÊNCIA 11
    for n in range(len(i)):

      if (n-1)%2 == 0:
        o.append(i[n-1]*i[n])
    #REFERÊNCIA 12
    m = sum(o)/len(o)
    return m

def multiplicalistas(x, y):
  i = []
  o = []
 
  for n in range(len(y)):
    i.append(y[n])
    i.append(x[n])

  for n in range(len(i)):
    if (n-1)%2 == 0:
      o.append(i[n-1]*i[n])
  return o

"""- Definimos duas listas vazias. A primeira vai receber a média de todos os meses durante os 20 anos de dados. A segunda vai receber o ano e mês do dado, mas no modelo ‘dado = [ano, mês, ano, mês]' onde um mesmo ano se repete 12 vezes. `REFERENCIA 13`
- Criamos uma listas com todos os meses do ano para o uso do filtros. `REFERENCIA 14`
- Cria-se um contador que abrange o período onde o data frame possui dados, sendo de 2002 a 2022. `REFERENCIA 15`
- Executamos um "while" que atue na duração de 20 anos, e um "for" que busca os meses da lista de meses. Para cada  "while" o "for" executa 12 vezes, assim nos dando as médias de todos os meses durante 2002 e 2022. `REFERENCIA 16`
"""

#REFERÊNCIA 13
lista_media_venda_mes = []
data = []

#REFERÊNCIA 14
meses = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

#REFERÊNCIA 15
ContadorAnos = 2002

#REFERÊNCIA 16
while ContadorAnos < 2023:
  for i in range(0,12):
    lista_media_venda_mes.append(medialistas(precos_mes_fechamento(ContadorAnos, meses[i]), quant_mes_volume(ContadorAnos, meses[i])))
    data.append(ContadorAnos)
    data.append(meses[i])
  ContadorAnos += 1

lista_media_fechamento_mes = []
meses = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
ContadorAnos = 2002

while ContadorAnos < 2023:
  for i in range(0,12):
    lista_media_fechamento_mes.append(medialista(precos_mes_fechamento(ContadorAnos, meses[i])))
  ContadorAnos += 1

lista_media_fechamento_1sem = []
lista_media_fechamento_2sem = []
lista_media_fechamento_1sem_mes = []
lista_media_fechamento_2sem_mes = []
lista_semestre_tempo = []
semestre_1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun"]
semestre_2 = ["Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
ContadorAnos = 2002

while ContadorAnos < 2023:
  for i in range(0,6):
   lista_media_fechamento_1sem_mes.append(medialista(precos_mes_fechamento(ContadorAnos, semestre_1[i])))
   lista_media_fechamento_2sem_mes.append(medialista(precos_mes_fechamento(ContadorAnos, semestre_2[i])))
  lista_semestre_tempo.append(f'{1 + (ContadorAnos - 2002)*2} semestre')
  lista_semestre_tempo.append(f'{2 + (ContadorAnos - 2002)*2} semestre')
  lista_media_fechamento_1sem.append(medialista(lista_media_fechamento_1sem_mes))
  lista_media_fechamento_2sem.append(medialista(lista_media_fechamento_2sem_mes))
  lista_media_fechamento_1sem_mes = []
  lista_media_fechamento_2sem_mes = []

  ContadorAnos += 1

lista_media_fechamento_semestre = []

for n in range(len(lista_media_fechamento_1sem)):
      lista_media_fechamento_semestre.append(lista_media_fechamento_1sem[n])
      lista_media_fechamento_semestre.append(lista_media_fechamento_2sem[n])

lista_quantidade_volume_1sem = []
lista_quantidade_volume_2sem = []
lista_quantidade_volume_1sem_mes = []
lista_quantidade_volume_2sem_mes = []
semestre_1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun"]
semestre_2 = ["Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
ContadorAnos = 2002

while ContadorAnos < 2023:
  for i in range(0,6):
   lista_quantidade_volume_1sem_mes.append(medialista(quant_mes_volume(ContadorAnos, semestre_1[i])))
   lista_quantidade_volume_2sem_mes.append(medialista(quant_mes_volume(ContadorAnos, semestre_2[i])))
  lista_quantidade_volume_1sem.append(medialista(lista_quantidade_volume_1sem_mes))
  lista_quantidade_volume_2sem.append(medialista(lista_quantidade_volume_2sem_mes))
  lista_quantidade_volume_1sem_mes = []
  lista_quantidade_volume_2sem_mes = []

  ContadorAnos += 1

lista_quantidade_volume_semestre = []

for n in range(len(lista_quantidade_volume_1sem)):
      lista_quantidade_volume_semestre.append(lista_quantidade_volume_1sem[n])
      lista_quantidade_volume_semestre.append(lista_quantidade_volume_2sem[n])

lista_media_venda_semestre = multiplicalistas(lista_quantidade_volume_semestre, lista_media_fechamento_semestre)

"""- Aqui a gente precisou fazer com que uma lista com itens organizados em [a, b, c, d](no caso a lista "data") se transformasse em uma lista com itens organizados em [(a, b), (c, d)](que vai ser a lista "lista_periodo"). Então ele verifica se o item é ímpar e, caso sim, ele adiciona uma string formatada à lista "lista_periodo". Primeiro ele adiciona o valor na posição "i" na lista "data" e em seguida o valor na posição "i+1", os dois separados por espaço. `REFERÊNCIA 17`"""

#REFÊNCIA 17
lista_periodo = []

for i in range(len(data)):
  if (i-1)%2 != 0:
    lista_periodo.append(f'{data[i]} {data[i+1]}')

px.line(Dataframeutilizado, x=lista_periodo, y=lista_media_fechamento_mes, 
        title="CAPITAL MOVIMENTADO COM BASE NO PREÇO DE FECHAMENTO",
        labels={"y": "CAPITAL MOVIMENTADO", "x": "ANO E MÊS"})

px.bar(Dataframeutilizado, x = lista_semestre_tempo, y = lista_media_venda_semestre, 
        title="CAPITAL MOVIMENTADO COM BASE NO PREÇO DE FECHAMENTO",
        labels={"y": "Valor de Fechamento", "x": "Semestres"})

"""# DASHBOARD

## Preparação do ambiente de programação do dashboard
- Para a execução dos códigos do dashboard é necessário instalar o "jupyter_dash", que será utilizado ao longo de todos os códigos. `REFERÊNCIA 1`

- Além disso, é necessário importar as bibliotecas que serão utilizadas ao longo de todos os códigos do dashboard. `REFERÊNCIA 2`
"""

#REFERÊNCIA 1
!pip install -qqq jupyter_dash
!pip install dash

#REFERÊNCIA 2
import dash
from dash import dcc
from dash import html
from dash import Input, Output
from jupyter_dash import JupyterDash

"""## Dashboard Análise 1 - Média de volume por ano"""

app = JupyterDash(__name__, title='Grupo12A')
meses = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
mesesTraduzidos = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
anosDeclarados = ["2002", "2003", "2004", "2005", "2006", "2007", "2008", "2009", "2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017",
"2018", "2019", "2020", "2021", "2022"]

def filtroAno(pdf, pano):
    pdfmes = {}
    for x in pdf:
        if x[0][-4:] == pano:
            mes = x[0][:3]
            if mes in pdfmes:
                pdfmes[mes].append(float(pd.to_numeric(x[6].replace(",", ""))))
            else:
                pdfmes[mes] = [float(pd.to_numeric(x[6].replace(",", "")))]
    for x in pdfmes:
        pdfmes[x] = sum(pdfmes[x])/len(pdfmes[x])

    return [[k, v] for k, v in pdfmes.items()]

app.layout = html.Div([
    html.H1(id='title', children='ANÁLISES SOBRE BARRIS DE PETRÓLEO NÃO REFINADO'),
    html.H2('ANÁLISE 1 - MÉDIA DE VOLUME POR ANO'),

    dcc.Graph(id='graph'),
    dcc.Slider(2002, 2022,
        step=None,
        value=2003,
        id='my-slider',
        marks={2002: "2002", 2003: "2003", 2004: "2004", 2005: "2005", 2006: "2006", 2007: "2007", 2008: "2008", 2009: "2009", 2010: "2010",
        2011: "2011", 2012: "2012", 2013: "2013", 2014: "2014", 2015: "2015", 2016: "2016", 2017: "2017", 2018: "2018", 2019: "2019", 2020: "2020",
        2021: "2021", 2022: "2022"
    }
    ),
])

@app.callback(
    dash.dependencies.Output('graph', 'figure'),
    [dash.dependencies.Input('my-slider', 'value')]
)

def update_graph(selected_value):
    filtered_df = filtroAno(ListaDataframeutilizado, str(selected_value))
    filtered_df.sort()
    variation = [round(x[1], 2) for x in filtered_df]

    return {
        'data': [{
            'x': mesesTraduzidos,
            'y': variation,
            'type': 'bar'
        }]
    }

if __name__ == '__main__':
    app.run_server(debug=True)

"""## Dashboard Análise 2 - Preço médio do barril de petróleo por ano"""

def grafico_media_anual(anos1):
  lista_media_anual = []
  meses1 = []
  ano_inicial = anos1[0]
  ano_final = anos1[1]
  while ano_inicial <= ano_final:
    for i in range(0,12):
      lista_media_anual.append(precos(ano_inicial,meses[i]))
      meses1.append(f'{ano_inicial} {meses[i]}')
    ano_inicial += 1

  lista_media_anual = ["%.2f" % (i) for i in lista_media_anual]
  lista_media_anual = [float (i) for i in lista_media_anual]

  fig = px.line(Dataframeutilizado,x=meses1, y=lista_media_anual, title='PREÇO MÉDIO DO BARRIL DE PETRÓLEO POR ANO', labels={"y": "PREÇO MÉDIO", "x": "ANO"})
  return fig

anos1 = [2002,2022]

def update_grafico2(value):
    return  grafico_media_anual(value)

"""## Dashboard Análise 3 - Capital movimentado"""

fig = GraficoCapitalMovimentado
fig.update_layout(
    title_text="CAPITAL MOVIMENTADO - CURVAS COM PREÇOS EM ALTA, MÉDIA E BAIXA"
)

fig.update_layout(
    xaxis=dict(
        rangeselector=dict(
            buttons=list([
                dict(count=1,
                     label="1 mês",
                     step="month",
                     stepmode="backward"),
                dict(count=6,
                     label="6 meses",
                     step="month",
                     stepmode="backward"),
                dict(count=1,
                     label="1 ano",
                     step="year",
                     stepmode="todate"),
                dict(label="Tudo",
                     step="all")
            ])
        ),
        rangeslider=dict(
            visible=True
        ),
        type="date"
    )
)

"""## Dashboard Análise 4 - Variação de preços considerando a abertura e o fechamento da bolsa"""

app = JupyterDash(__name__, title='Grupo12A')

#A variável "meses" foi criada para buscar os meses selecionados na função FOR, e o "mesesTraduzidos" para serem expostos no gráfico.
meses = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
mesesTraduzidos = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]

# A função "filtroMes" é responsável por filtrar o Dataframe de acordo com o mês selecionado pelo usuário. 
# Ela itera por todas as linhas do Dataframe e verifica se o mês corresponde ao mês selecionado. 
# Em seguida, ela armazena o ano e a variação de preço em um dicionário. 
# Por fim, a função retorna uma lista de listas com os anos e a variação de preço média para o ano.
def filtroMes(pdf, pmes):
    pdfmes = {}
    for x in pdf:
        if x[0][:3] == pmes:
            ano = x[0][-4:]
            if ano in pdfmes:
                pdfmes[ano].append(x[4]-x[1])
            else:
                pdfmes[ano] = [x[4]-x[1]]

# Média da Variação dos dias em determinado mês 
    for x in pdfmes:
        pdfmes[x] = sum(pdfmes[x])/len(pdfmes[x])

# Esta linha é uma lista de compreensão que está criando uma lista de listas, onde cada lista interna é composta por dois elementos: 
# a chave (k) e o valor (v) do dicionário pdfmes. pdfmes.items() retorna uma lista de pares de chaves e valores do dicionário. 
# A lista de compreensão então itera por esses pares e cria uma nova lista com cada par na forma de uma lista de dois elementos.
    return [[k, v] for k, v in pdfmes.items()]


# O título exibe a string "Variação por ano", o dropdown permite selecionar o mês desejado para exibir no gráfico 
# e o gráfico exibe a variação média por ano para o mês selecionado.
app.layout = html.Div([
    html.H1(id='title', children='ANÁLISES SOBRE BARRIS DE PETRÓLEO NÃO REFINADO'),
    html.H2('ANÁLISE 4 - VARIAÇÃO DE PREÇOS CONSIDERANDO A ABERTURA E O FECHAMENTO DA BOLSA'),
    dcc.Dropdown(
        id='idanalise4',
        options=[{'label': mesesTraduzidos[i], 'value': meses[i]} for i in range(len(mesesTraduzidos))],
        value='Jan'
    ),
    dcc.Graph(id='idslideanalise4')
])

@app.callback(
    Output('idslideanalise4', 'figure'),
    [Input('idanalise4', 'value')]
)

# Essa função é especificada como o retorno da dependência de saída do componente gráfico para a dependência de entrada do componente Dropdown. 
# Em outras palavras, essa função é chamada quando o componente gráfico precisa ser atualizado, 
# com base no valor selecionado pelo usuário no componente Dropdown.
def update_graph(selected_value):
    filtered_df = filtroMes(Dataframeutilizado.values.tolist(), selected_value)
    filtered_df.sort()
    years = [x[0] for x in filtered_df]
    variation = [round(x[1], 2) for x in filtered_df]

    return {
        'data': [{
            'x': years,
            'y': variation,
            'type': 'bar'
        }]
    }

if __name__ == '__main__':
    app.run_server(debug=True)

"""## Dashboard Análise 5 - Capital movimentado com base no preço de fechamento da bolsa"""

external_stylesheets = ['']

app = JupyterDash(__name__, title='Grupo12A')
app = JupyterDash(__name__, external_stylesheets=external_stylesheets)

#database da analise 5
database5tempo = {
    'Meses': lista_periodo,
    'Semestres': lista_semestre_tempo,
}

app.layout = html.Div(children=[
    html.H1(id='title', children='ANÁLISES SOBRE BARRIS DE PETRÓLEO NÃO REFINADO'),

    #Dashbord da Analise 5{
    html.H2(id='text1', children='''ANÁLISE 5 - CAPITAL MOVIMENTADO COM BASE NO PREÇO DE FECHAMENTO DA BOLSA'''),

    dcc.Dropdown(
        id = 'dropdown_gustavo_analise',
        options=[
              {'label': 'Capital Movimentado F', 'value': 'Capital Movimentado F'},
              {'label': 'Valor de Fechamento', 'value': 'Valor de Fechamento'},
        ],
        value = 'Capital Movimentado F'
    ),

    dcc.Dropdown(
        id = 'dropdown_gustavo_tempo',
        options=[
            {'label': 'Meses', 'value': 'Meses'},
            {'label': 'Semestres', 'value': 'Semestres'},
        ],
        value = 'Meses'
    ),

    dcc.Graph(
        id='graficogustavo',
        config = {'displayModeBar': False},
    ),

    #Fim do Dash da Analise 5}
])

@app.callback(
        Output('graficogustavo', 'figure'),
        [
        Input('dropdown_gustavo_analise', 'value'),
        Input('dropdown_gustavo_tempo', 'value')
        ]
)

def updategrafico5(dropdown_gustavo_analise,dropdown_gustavo_tempo):

  if dropdown_gustavo_tempo == 'Meses':
    database5analise = {
      'Capital Movimentado F': lista_media_venda_mes,
      'Valor de Fechamento': lista_media_fechamento_mes,
    }

  elif dropdown_gustavo_tempo == 'Semestres':
    database5analise = {
      'Capital Movimentado F': lista_media_venda_semestre,
      'Valor de Fechamento': lista_media_fechamento_semestre,
    }

  return {
      'data': [
          {
              'y': database5analise[dropdown_gustavo_analise],
              'x': database5tempo[dropdown_gustavo_tempo],
          },
      ], 
      'layout': {
          'title': dropdown_gustavo_analise,
      },
  }


if __name__ == '__main__':
    app.run_server(debug=True)

"""## LIGAR SITE"""

external_stylesheets = ['']

app = JupyterDash(__name__, title='Grupo12A')

app.layout = html.Div(children=[
    html.H1(id='title', children='ANÁLISES SOBRE BARRIS DE PETRÓLEO NÃO REFINADO'),
#--------------------------------------------------------------------------------------------------------------------
#---------------------------------------------[ANÁLISE 1]------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------
    html.H2('ANÁLISE 1 - MÉDIA DE VOLUME POR ANO'),

    dcc.Graph(id='graph'),
    dcc.Slider(2002, 2022,
        step=None,
        value=2003,
        id='my-slider',
        marks={2002: "2002", 2003: "2003", 2004: "2004", 2005: "2005", 2006: "2006", 2007: "2007", 2008: "2008", 2009: "2009", 2010: "2010",
        2011: "2011", 2012: "2012", 2013: "2013", 2014: "2014", 2015: "2015", 2016: "2016", 2017: "2017", 2018: "2018", 2019: "2019", 2020: "2020",
        2021: "2021", 2022: "2022"
    }
    ),
#--------------------------------------------------------------------------------------------------------------------
#---------------------------------------------[ANÁLISE 2]------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------
    html.H2(id='text1', children='''
        ANÁLISE 2 - PREÇO MÉDIO DO BARRIL DE PETRÓLEO POR ANO
    '''),
# Definimos aqui, o gráfico da Análise 2.
    dcc.Graph(
        id='idanalise2',
        figure = grafico_media_anual(anos1)
    ),
# A figure recebe a função grafico_media_anual(anos1), aonde 'anos1' recebe uma lista com os valores dos anos definidos pelo usuário. 

# O Slider define os anos a serem analisados, em uma lista com dois valores. Tem como padrão os anos de '2002' a '2022'.
    dcc.RangeSlider(2002, 2022, 1,marks={
      2002: '2002',
      2003: '2003',
      2004: '2004',
      2005: '2005',
      2006: '2006',
      2007: '2007',
      2008: '2008',
      2009: '2009',
      2010: '2010',
      2011: '2011',
      2012: '2012',
      2013: '2013',
      2014: '2014',
      2015: '2015',
      2016: '2016',
      2017: '2017',
      2018: '2018',
      2019: '2019',
      2020: '2020',
      2021: '2021',
      2022: '2022',
    }, value=[2002, 2022], tooltip={"placement": "bottom", "always_visible": True}, id='idslideranalise2'),

#--------------------------------------------------------------------------------------------------------------------
#---------------------------------------------[ANÁLISE 3]------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------

    html.H2(id='text1', children='''
        ANÁLISE 3 - CAPITAL MOVIMENTADO
    '''),

    dcc.Graph(
        id='Média anual',
        figure=GraficoCapitalMovimentado
    ),

#--------------------------------------------------------------------------------------------------------------------
#---------------------------------------------[ANÁLISE 4]------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------
    html.H2('ANÁLISE 4 - VARIAÇÃO DE PREÇOS CONSIDERANDO A ABERTURA E O FECHAMENTO DA BOLSA'),
    dcc.Dropdown(
        id='idanalise4',
        options=[{'label': mesesTraduzidos[i], 'value': meses[i]} for i in range(len(mesesTraduzidos))],
        value='Jan'
    ),
    dcc.Graph(id='idslideanalise4'),
#--------------------------------------------------------------------------------------------------------------------
#---------------------------------------------[ANÁLISE 5]------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------
    #Dashbord da Analise 5{
    html.H2(id='text1', children='''ANÁLISE 5 - CAPITAL MOVIMENTADO COM BASE NO PREÇO DE FECHAMENTO DA BOLSA'''),

    dcc.Dropdown(
        id = 'dropdown_gustavo_analise',
        options=[
            {'label': 'Capital Movimentado F - Meses', 'value': 'Capital Movimentado F - Meses'},
            {'label': 'Valor de Fechamento - Meses', 'value': 'Valor de Fechamento - Meses'},
            {'label': 'Capital Movimentado F - Semestre', 'value': 'Capital Movimentado F - Semestre'},
            {'label': 'Valor de Fechamento - Semestre', 'value': 'Valor de Fechamento - Semestre'},
        ],
        value = 'Capital Movimentado - Meses'
    ),

    dcc.Dropdown(
        id = 'dropdown_gustavo_tempo',
        options=[
            {'label': 'Meses', 'value': 'Meses'},
            {'label': 'Semestres', 'value': 'Semestres'},
        ],
        value = 'Meses'
    ),

    dcc.Graph(
        id='graficogustavo',
        config = {'displayModeBar': False},
    ),
])
@app.callback(
    dash.dependencies.Output('graph', 'figure'),
    [dash.dependencies.Input('my-slider', 'value')]
)

def update_graph(selected_value):
    filtered_df = filtroAno(ListaDataframeutilizado, str(selected_value))
    filtered_df.sort()
    variation = [round(x[1], 2) for x in filtered_df]

    return {
        'data': [{
            'x': mesesTraduzidos,
            'y': variation,
            'type': 'bar'
        }]
    }

@app.callback(
    Output('idslideanalise4', 'figure'),
    [Input('idanalise4', 'value')]
)

# Essa função é especificada como o retorno da dependência de saída do componente gráfico para a dependência de entrada do componente Dropdown. 
# Em outras palavras, essa função é chamada quando o componente gráfico precisa ser atualizado, 
# com base no valor selecionado pelo usuário no componente Dropdown.
def update_graph(selected_value):
    filtered_df = filtroMes(Dataframeutilizado.values.tolist(), selected_value)
    filtered_df.sort()
    years = [x[0] for x in filtered_df]
    variation = [round(x[1], 2) for x in filtered_df]

    return {
        'data': [{
            'x': years,
            'y': variation,
            'type': 'bar'
        }]
    }

# Chamamos o 'app.callback' para que o valor definido no RangeSlider seja transmitido ao gráfico.
# No output, temos a id definida para o gráfico e a figure com o valor que será alterado.
# No input, temos a id do RangeSlider e o value, que será o valor definido pelo usuário.

@app.callback(
    Output('idanalise2', 'figure'),
    [Input('idslideranalise2', 'value')])

# A função 'update_grafico2(value)' tem como definição alterar o valor 'anos1' da função 'grafico_media_anual(anos1)' para o 'value'
# definido no RangeSlider. A função 'grafico_media_anual(anos1)' tem como parâmetro uma lista com dois valores, tal qual o
# 'value' do RangeSlider.

def update_grafico2(value):
    return  grafico_media_anual(value)

@app.callback(
        Output('graficogustavo', 'figure'),
        [
        Input('dropdown_gustavo_analise', 'value'),
        Input('dropdown_gustavo_tempo', 'value')
        ]
)

def updategrafico5(dropdown_gustavo_analise,dropdown_gustavo_tempo):
  return {
      'data': [
          {
              'y': database5[dropdown_gustavo_analise],
              'x': database5[dropdown_gustavo_tempo],
          },
      ], 
      'layout': {
          'title': dropdown_gustavo_analise,
      },
  }

if __name__ == '__main__':
    app.run_server(debug=True)